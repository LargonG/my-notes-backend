[] Дописать сервисы
    [] Понять, на каком уровне абстракции делать авторизацию пользователя
    [] Рассмотрим несколько методов реализации авторизации:
        [] Через implicit -- нет, потому что у нас один сервер, то есть он
        должен уметь работать много поточно, а implicit делает наш код не читаемым
        Короче, лучше его не использовать, потому что это бессмысленно
        [] Reader
        [] Явно прокидывать в функции, там, где надо
        [] Сделать отдельный объект, который строит права основываясь на роли пользователя
        А также на его универсальном токене. Мы будем передавать его в Reader,
        и вызывать auth.check() каждый раз, когда хотим что-либо проверить.
        check потребуется знать название функции и её аргументы, а также нужно
        будет создать несколько объектов, которые описывают поведение нашего checker
        Звучит сложно, непонятно, но это лучше, чем ничего.

        Иначе мы можем... создать ещё одну абстракцию, которая делает
        security и уже после того, как она проверила, что всё хорошо,
        вызывает основной сервис. Вопрос только тогда, зачем нам разделять
        Service и Security логики, если они на столько связаны, что будут
        принимать по факту одни и те же значения
        С другой стороны, вдруг мы захотим несколько логик предоставления безопасности,
        в зависимости от того, откуда мы запускаем то или иное действие.
        Этот метод даёт большую гибкость и позволяет слегка абстрагироваться от
        чистой бизнес-логики